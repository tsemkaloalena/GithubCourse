**Конфигурация пользователя**
git config user.name
git config user.email записывается в .git/config
**3 уровня конфигурации:**
локальный --local (default) (<project>/.git/config), глобальный --global (~/.gitconfig, C:/users/<user>/.gitconfig) и системный --system (C/:Program Files/Git/etc/gitconfig)
**Чтение конфигураций:**
git config --list 
git config --list --global
**Удалить секцию**
git config --remove-section user
**Добавление своих команд**
git config alias.sayhi ‘echo …’
Вызов git sayhi
**Просмотр информации**
git config -h
Более подробно git help config
Внутри: 
 ⁃ поиск строки - “/<строка>”
 ⁃ n - поиск вперёд
 ⁃ Shift+n - поиск назад

**Создание репозитория:**
git init 
git status - просмотр состояния репозитория 
git add index.html - добавление файла в индекс (отслеживание)
git commit
git show - информация о коммите 
Гит не видит пустые папки
git commit -a (--all) - коммитит все изменения
git commit -m ‘’ index.html - коммитит указанный файл
git rm index.html - удаление файла

**Переключение в другую ветку**
git checkout …
git branch - создание ветки
git branch -v - текущее состояние ветки
**Сохранение незакоммиченных файлов при переключении веток**
git stash
git stash pop
**Переместить указатель ветки на конкретный коммит**
git branch -f master commit-id
**Detached HEAD – состояние, когда мы не находимся на какой то определенной ветке**
git log – информация о всех коммитах в ветки репозитория от HEAD
git show filename.html – показать содержимое файла из HEAD
git show :/MIB-1488 – показать коммит с MIB-1488 в описании
**Объединение веток**
git merge fix – объединить текущую ветку с fix
в файле .git/ORIG_HEAD находится название бывшего HEAD текущей ветки
**Удаление ветки**
git branch -d fix – удалить ветку, все коммиты которой есть в другой ветке
git branch -D fix – удалить ветку со всеми её личными ком митами
удалением можно отменить созданием git branch fix commit-id
**Логи по всем переключениям HEAD**
git reflog –date=iso
можно восстановить ветку по старым коммитам git branch fix ‘HEAD{number from reflog}’ 
git checkout @{-1} – переключение на предыдущую ветку
**Полностью очистить изменения**
git reset –hard – удалит все отслеживаемые файлы, которые появились с момента прошлого коммита
git clean -dxf – удалит все неостлеживаемые, игнорируемые файлы и директории, которые появились с момента прошлого коммита
@- head
~ - родитель текущего коммита
**Сброс до коммита**
git reset –hard commit_id
если нужно вернуться к удаленному, то git reset –hard ORIG_HEAD (буквально ORIG_HEAD, это ссылка на удаленный коммит)
git reset –soft @~ отменяет коммит, но оставляет в индексе изменения сделанные этим коммитом
git commit –amend - объединение отката до прошлого коммита плюс коммит новых изменений
git reset = git reset –mixed – откат до коммита указанного с удалением файлов из индексирования
**История репозитория**
git diff – различия между файлами в коммитах и ветках
git diff –cached – проиндексированные изменения, которые попадут в следующий коммит
**Логирование может быть форматировано флагами**
git log –pretty=format:’format_style’
git log –grep Run branch_name – поиск коммитов с описанием содержащим Run из ветки branch_name
git blame – показывает в каком последнем коммите была изменена каждая из строк файла
**Объединение веток**
git merge feature – объединит ветку feature с текущей веткой
git log master –oneline –first-parent – показывает коммиты только от ветки мастер
git merge –squash feature отдельным коммитом в ветку текущую будут добавлены все изменения между текущей и feature
**Отмена merge**
git reset –hard @~
**Копирование коммитов**
git cherry-pick commit_id – скопирует коммит в текущую ветку
git cherry-pick -n commit_id – скопирует изменения в индекс, но не будет коммитить
**Перемещение коммитов**
git rebase master – скопировать все коммиты текущей ветки поверх ветки master
 Операция merge безопасна, она не меняет предыдущие. Операция rebase может привести к проблемам из-за перекопированния. Rebase можно делать локально и если веткой занимается один человек.
git rebase -x ‘command’ – выполнение комманд после каждого копирования коммита, используется в тестах и позволяет выявить ошибки
git rebase –onto master feature – переместить все коммиты текущей ветки на мастер начиная от отхождения от feature
![image](https://github.com/user-attachments/assets/4bdcbb6b-56ea-4cd9-aa7d-3aa8f3003128)

git rebase -i master – интерактивное перебазирование, открывает редактор с возможностью выбора действий
![image](https://github.com/user-attachments/assets/305f79f8-308b-430a-b759-06fdd5e45f06)

git rebase -i @~count – открыть редактор для count предыдущих коммитов текущей ветки
  Отмена коммитов
git revert – @ - создать коммит, удаляющие изменения из последнего коммита
В сценарии где произошел revert коммита merge, ту ветку которая мерджилась стоит rebase поверх revert
git rebase –onto master commit_id feature, где commit_id это коммит родитель ветки feature
можно также создать полную копию ветки, которая однако не будет иметь связей с master, а от этого и не будет пропущенных коммитов 
git rebase commit_id –no-ff. Это не просто подвинет указатель на текущую ветку, а буквально перекопирует коммиты и только потом передвинет указатель
